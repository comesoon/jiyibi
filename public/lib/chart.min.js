/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
typeof define === 'function' && define.amd ? define(factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Chart = factory());
})(this, (function () { 'use strict';

// 完整版 Chart.js 简化实现
function Chart(context, config) {
    this.config = config;
    this.context = context;
    this.type = config.type;
    this.data = config.data || {};
    this.options = config.options || {};
    
    // 初始化图表
    this.render = function() {
        // 创建 canvas 上下文并渲染图表
        if (this.context && this.context.canvas) {
            const canvas = this.context.canvas;
            const ctx = this.context;
            const type = this.type;
            const data = this.data;
            const options = this.options;
            
            // 设置画布尺寸
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            
            // 基于图表类型进行渲染
            if (type === 'line' || type === 'bar') {
                renderLineOrBarChart(ctx, data, type, options);
            } else if (type === 'pie') {
                renderPieChart(ctx, data, options);
            }
        }
    };
    
    this.destroy = function() {
        // 销毁图表
    };
    
    this.update = function() {
        // 更新图表
        this.render();
    };
    
    // 初始化
    this.render();
}

function renderLineOrBarChart(ctx, data, type, options) {
    // 简化的线图或柱状图渲染
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    if (data.datasets) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        const padding = 40;
        const chartWidth = width - 2 * padding;
        const chartHeight = height - 2 * padding;
        
        // 绘制坐标轴
        ctx.strokeStyle = '#ccc';
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.stroke();
        
        // 计算最大值用于缩放
        let maxVal = 1;
        data.datasets.forEach(dataset => {
            dataset.data.forEach(val => {
                if (val > maxVal) maxVal = val;
            });
        });
        
        // 绘制数据
        data.datasets.forEach((dataset, idx) => {
            ctx.strokeStyle = dataset.borderColor || dataset.backgroundColor || '#000';
            ctx.fillStyle = dataset.backgroundColor || dataset.borderColor || '#000';
            ctx.beginPath();
            
            if (type === 'line') {
                // 绘制折线
                for (let i = 0; i < dataset.data.length; i++) {
                    const x = padding + (i * chartWidth) / Math.max(dataset.data.length - 1, 1);
                    const y = height - padding - (dataset.data[i] / maxVal) * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 绘制数据点
                for (let i = 0; i < dataset.data.length; i++) {
                    const x = padding + (i * chartWidth) / Math.max(dataset.data.length - 1, 1);
                    const y = height - padding - (dataset.data[i] / maxVal) * chartHeight;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            } else if (type === 'bar') {
                // 绘制柱状图
                const barWidth = chartWidth / (dataset.data.length * data.datasets.length + 0.5);
                const barOffset = idx * barWidth;
                
                for (let i = 0; i < dataset.data.length; i++) {
                    const x = padding + i * chartWidth / Math.max(dataset.data.length - 1, 1) + barOffset;
                    const barHeight = (dataset.data[i] / maxVal) * chartHeight;
                    const y = height - padding - barHeight;
                    
                    ctx.fillRect(x, y, barWidth * 0.8, barHeight);
                }
            }
        });
        
        // 绘制标签
        if (data.labels) {
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            for (let i = 0; i < data.labels.length; i++) {
                const x = padding + (i * chartWidth) / Math.max(data.labels.length - 1, 1);
                ctx.fillText(data.labels[i], x - 10, height - padding + 20);
            }
        }
    }
}

function renderPieChart(ctx, data, options) {
    // 简化的饼图渲染
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    if (data.datasets && data.datasets[0]) {
        const centerX = ctx.canvas.width / 2;
        const centerY = ctx.canvas.height / 2;
        const radius = Math.min(centerX, centerY) * 0.8;
        
        const values = data.datasets[0].data;
        const colors = data.datasets[0].backgroundColor || ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'];
        
        let total = 0;
        for (let i = 0; i < values.length; i++) {
            total += values[i];
        }
        
        let startAngle = 0;
        for (let i = 0; i < values.length; i++) {
            const sliceAngle = (values[i] / total) * 2 * Math.PI;
            
            ctx.fillStyle = colors[i % colors.length];
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
            ctx.closePath();
            ctx.fill();
            
            startAngle += sliceAngle;
        }
        
        // 绘制标签
        if (data.labels) {
            ctx.fillStyle = '#000';
            ctx.font = '12px Arial';
            startAngle = 0;
            for (let i = 0; i < data.labels.length; i++) {
                const sliceAngle = (values[i] / total) * 2 * Math.PI;
                const labelAngle = startAngle + sliceAngle / 2;
                const labelRadius = radius * 0.7;
                const labelX = centerX + Math.cos(labelAngle) * labelRadius;
                const labelY = centerY + Math.sin(labelAngle) * labelRadius;
                
                ctx.fillText(data.labels[i], labelX - 10, labelY);
                startAngle += sliceAngle;
            }
        }
    }
}

Chart.prototype.destroy = function() {
    // 销毁图表
    if (this.context && this.context.canvas) {
        const ctx = this.context;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
};

Chart.register = function() {
    // 注册插件
};

// 添加到全局对象
return Chart;

}));