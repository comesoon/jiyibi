/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
typeof define === 'function' && define.amd ? define(factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Chart = factory());
})(this, (function () { 'use strict';

// 完整版 Chart.js 简化实现
function Chart(context, config) {
    this.config = config;
    this.context = context;
    this.type = config.type;
    this.data = config.data || {};
    this.options = config.options || {};
    
    // 初始化图表
    this.render = function() {
        // 创建 canvas 上下文并渲染图表
        if (this.context && this.context.canvas) {
            const canvas = this.context.canvas;
            const ctx = this.context;
            const type = this.type;
            const data = this.data;
            const options = this.options;
            
            // 设置画布尺寸
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            
            // 基于图表类型进行渲染
            if (type === 'line' || type === 'bar') {
                renderLineOrBarChart(ctx, data, type, options);
            } else if (type === 'pie') {
                renderPieChart(ctx, data, options);
            }
        }
    };
    
    this.destroy = function() {
        // 销毁图表
    };
    
    this.update = function() {
        // 更新图表
        this.render();
    };
    
    // 初始化
    this.render();
}

function renderLineOrBarChart(ctx, data, type, options) {
    // 简化的线图或柱状图渲染
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    if (data.datasets) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        const padding = 50;
        const chartWidth = width - 2 * padding;
        const chartHeight = height - 2 * padding - 40; // 为图例留出空间
        
        // 绘制坐标轴
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 1;
        
        // Y轴
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding - 40);
        ctx.stroke();
        
        // X轴
        ctx.beginPath();
        ctx.moveTo(padding, height - padding - 40);
        ctx.lineTo(width - padding, height - padding - 40);
        ctx.stroke();
        
        // 计算最大值和最小值用于缩放
        let maxVal = -Infinity;
        let minVal = Infinity;
        data.datasets.forEach(dataset => {
            dataset.data.forEach(val => {
                if (val > maxVal) maxVal = val;
                if (val < minVal) minVal = val;
            });
        });
        
        // 如果所有值都相等，设置一个合理的范围
        if (maxVal === minVal) {
            if (maxVal === 0) {
                maxVal = 1;
                minVal = -1;
            } else {
                const range = Math.abs(maxVal) * 0.1;
                maxVal += range;
                minVal -= range;
            }
        }
        
        const valueRange = maxVal - minVal;
        
        // 绘制Y轴刻度和标签
        ctx.fillStyle = '#666';
        ctx.font = '10px Arial';
        ctx.textAlign = 'right';
        const ySteps = 5;
        for (let i = 0; i <= ySteps; i++) {
            const value = minVal + (ySteps - i) * (valueRange / ySteps);
            const y = padding + i * (chartHeight / ySteps);
            
            // 绘制刻度线
            ctx.beginPath();
            ctx.moveTo(padding - 5, y);
            ctx.lineTo(padding, y);
            ctx.stroke();
            
            // 绘制标签
            ctx.fillText(value.toFixed(1), padding - 10, y + 4);
        }
        
        // 绘制数据
        const datasetCount = data.datasets.length;
        const xPointCount = data.labels ? data.labels.length : Math.max(...data.datasets.map(d => d.data.length));
        
        data.datasets.forEach((dataset, idx) => {
            const color = dataset.borderColor || dataset.backgroundColor || `hsl(${idx * 60}, 70%, 50%)`;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            if (type === 'line') {
                // 绘制折线
                ctx.beginPath();
                for (let i = 0; i < dataset.data.length; i++) {
                    const x = padding + (i * chartWidth) / Math.max(xPointCount - 1, 1);
                    const y = padding + (chartHeight - ((dataset.data[i] - minVal) / valueRange) * chartHeight);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // 绘制数据点
                for (let i = 0; i < dataset.data.length; i++) {
                    const x = padding + (i * chartWidth) / Math.max(xPointCount - 1, 1);
                    const y = padding + (chartHeight - ((dataset.data[i] - minVal) / valueRange) * chartHeight);
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                }
            } else if (type === 'bar') {
                // 绘制柱状图
                const groupWidth = chartWidth / Math.max(xPointCount, 1);
                const barWidth = groupWidth / datasetCount * 0.8;
                const barOffset = (groupWidth - barWidth * datasetCount) / 2 + idx * barWidth;
                
                for (let i = 0; i < dataset.data.length; i++) {
                    const x = padding + i * groupWidth + barOffset;
                    const barHeight = ((dataset.data[i] - minVal) / valueRange) * chartHeight;
                    const y = padding + chartHeight - barHeight;
                    
                    ctx.fillRect(x, y, barWidth, barHeight);
                }
            }
        });
        
        // 绘制X轴标签
        if (data.labels) {
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (let i = 0; i < data.labels.length; i++) {
                const x = padding + (i * chartWidth) / Math.max(data.labels.length - 1, 1);
                ctx.fillText(data.labels[i], x, height - padding - 35);
            }
        }
        
        // 绘制图例
        if (data.datasets && data.datasets.length > 0) {
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            const legendY = height - 25;
            let legendX = padding;
            
            data.datasets.forEach((dataset, idx) => {
                const label = dataset.label || `数据集 ${idx + 1}`;
                const color = dataset.borderColor || dataset.backgroundColor || `hsl(${idx * 60}, 70%, 50%)`;
                
                // 绘制图例颜色框
                ctx.fillStyle = color;
                ctx.fillRect(legendX, legendY - 6, 12, 12);
                
                // 绘制图例文本
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText(label, legendX + 18, legendY);
                
                // 计算下一个图例的位置
                const textWidth = ctx.measureText(label).width;
                legendX += 18 + textWidth + 20; // 18是颜色框和文本的间距，20是图例项之间的间距
            });
        }
    }
}

function renderPieChart(ctx, data, options) {
    // 简化的饼图渲染
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    if (data.datasets && data.datasets[0]) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        
        // 为图例预留空间
        const chartHeight = height - 60; // 为图例留出空间
        const centerX = width / 2;
        const centerY = chartHeight / 2;
        const radius = Math.min(width, chartHeight) * 0.4;
        
        const values = data.datasets[0].data;
        const colors = data.datasets[0].backgroundColor || ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#C9CBCF'];
        const labels = data.labels || [];
        
        let total = 0;
        for (let i = 0; i < values.length; i++) {
            total += values[i];
        }
        
        if (total === 0) {
            // 如果总值为0，绘制一个空心圆
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.stroke();
            return;
        }
        
        let startAngle = 0;
        for (let i = 0; i < values.length; i++) {
            const sliceAngle = (values[i] / total) * 2 * Math.PI;
            
            ctx.fillStyle = colors[i % colors.length];
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
            ctx.closePath();
            ctx.fill();
            
            // 绘制边框
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            startAngle += sliceAngle;
        }
        
        // 绘制标签和数值
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = '12px Arial';
        ctx.fillStyle = '#fff';
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 2;
        
        startAngle = 0;
        for (let i = 0; i < values.length; i++) {
            if (values[i] === 0) continue;
            
            const sliceAngle = (values[i] / total) * 2 * Math.PI;
            const labelAngle = startAngle + sliceAngle / 2;
            const labelRadius = radius * 0.7;
            const labelX = centerX + Math.cos(labelAngle) * labelRadius;
            const labelY = centerY + Math.sin(labelAngle) * labelRadius;
            
            // 绘制百分比
            const percentage = ((values[i] / total) * 100).toFixed(1);
            ctx.fillText(`${percentage}%`, labelX, labelY);
            
            startAngle += sliceAngle;
        }
        
        // 恢复阴影设置
        ctx.shadowBlur = 0;
        
        // 绘制图例
        if (labels.length > 0) {
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            const legendY = chartHeight + 20; // 图例在饼图下方
            let legendX = 20;
            
            for (let i = 0; i < labels.length; i++) {
                const color = colors[i % colors.length];
                
                // 绘制图例颜色框
                ctx.fillStyle = color;
                ctx.fillRect(legendX, legendY - 6, 12, 12);
                
                // 绘制图例文本
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.fillText(labels[i], legendX + 18, legendY);
                
                // 计算下一个图例的位置
                const textWidth = ctx.measureText(labels[i]).width;
                legendX += 18 + textWidth + 20; // 18是颜色框和文本的间距，20是图例项之间的间距
                
                // 如果图例超出画布宽度，换行显示
                if (legendX + 100 > width && i < labels.length - 1) {
                    legendX = 20;
                    // 如果只有一行空间，可以在这里增加行数，简化处理
                }
            }
        }
    }
}

Chart.prototype.destroy = function() {
    // 销毁图表
    if (this.context && this.context.canvas) {
        const ctx = this.context;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
};

Chart.register = function() {
    // 注册插件
};

// 添加到全局对象
return Chart;

}));